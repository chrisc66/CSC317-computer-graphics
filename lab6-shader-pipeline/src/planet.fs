// Generate a procedural planet and orbiting moon. Use layers of (improved)
// Perlin noise to generate planetary features such as vegetation, gaseous
// clouds, mountains, valleys, ice caps, rivers, oceans. Don't forget about the
// moon. Use `animation_seconds` in your noise input to create (periodic)
// temporal effects.
//
// Uniforms:
uniform mat4 view;
uniform mat4 proj;
uniform float animation_seconds;
uniform bool is_moon;
// Inputs:
in vec3 sphere_fs_in;
in vec3 normal_fs_in;
in vec4 pos_fs_in; 
in vec4 view_pos_fs_in; 
// Outputs:
out vec3 color;
// expects: model, blinn_phong, bump_height, bump_position,
// improved_perlin_noise, tangent
void main()
{
  /////////////////////////////////////////////////////////////////////////////
  // Replace with your code 
  // Re-using lit.fs code with additional bumps and noises

  /******************** Terrain (Bumps) ********************/
  /* Note: Terrain is generated by bumps and compare its height to sea level */
  /* Higher than sea level height is land and mountain (green) */
  /* Lower than sea level height is ocean (blue) */
  // tangent & bump
  vec3 T, B;
  tangent(sphere_fs_in, T, B);
  float epsilon = 0.0001;
  vec3 bump = bump_position(is_moon, sphere_fs_in);
  vec3 delta_t = (bump_position(is_moon, sphere_fs_in + epsilon * T) - bump) / epsilon;
  vec3 delta_b = (bump_position(is_moon, sphere_fs_in + epsilon * B) - bump) / epsilon;
  // height at each point
  float current_height = bump_height(is_moon, sphere_fs_in);
  float sea_height = 0.007;

  /******************** Cloud (Noises) ********************/
  /* Note: Cloud is white noises on earth's surface */
  // turbulence & perlin_noise
  float w = 0.8; // w: noise strength
  float k1 = 10; // k1: noise frequency
  float k2 = 8; // k2: noise frequency
  float noise = (1 + sin(k1 * (sphere_fs_in.z + improved_perlin_noise(k2 * sphere_fs_in)))/w)/2;

  /******************** Coloring ********************/
  // blinn_phong argument p
  float p = 1000.0;
  // blinn_phong argument v
  vec3 v = - normalize(view_pos_fs_in).xyz;
  // blinn_phong argument l
  float theta = 2 * M_PI * animation_seconds / 4;
  vec4 light = view * vec4(2 * cos(theta), 1, 2 * sin(theta), 1);
  vec3 l = normalize(light - view_pos_fs_in).xyz;
  // blinn_phong argument n
  // vec3 n = normalize(normal_fs_in);
  mat4 model = model(is_moon, animation_seconds / 4);
  vec3 delta_n = normalize(cross(delta_t, delta_b));
  vec3 n = normalize(transpose(inverse(view)) * transpose(inverse(model)) * vec4(delta_n,1)).xyz;

  // Moon
  if (is_moon){
    vec3 ka = vec3(0.1, 0.1, 0.05);
    vec3 kd = vec3(0.5, 0.5, 0.5);
    vec3 ks = vec3(0.8, 0.8, 0.8);
    color = blinn_phong(ka, kd, ks, p, n, v, l);
  }
  // Earth - ocean, water
  else if (current_height < sea_height){
    vec3 ka = vec3(0.08, 0.08, 0.24);
    vec3 kd = mix(vec3(0.2, 0.2, 0.6), vec3(3), noise);
    vec3 ks = vec3(0.8, 0.8, 0.8);
    color = blinn_phong(ka, kd, ks, p, n, v, l);
  }
  // Earth - mountain
  else {
    vec3 ka = vec3(0.08, 0.24, 0.16);
    vec3 kd = mix(vec3(0.2, 0.2, 0.6), vec3(3), noise);
    vec3 ks = vec3(0.8, 0.8, 0.8);
    color = blinn_phong(ka, kd, ks, p, n, v, l);
  }

  /////////////////////////////////////////////////////////////////////////////
}
